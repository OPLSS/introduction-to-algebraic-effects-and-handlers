(* This example is described in Section 6.10 of "Programming with Algebraic Effects and
   Handlers" by A. Bauer and M. Pretnar. *)

effect Yield : unit
effect Spawn : (unit -> unit) -> unit

(* We will need a queue to keep track of inactive threads.
   We implement the queue as state. *)

effect Dequeue : unit -> (unit -> unit) option
effect Enqueue : (unit -> unit) -> unit

(* The queue handler *)
let queue initial = handler
  | effect Dequeue k ->
    (fun queue -> match queue with
       | [] -> k None []
       | hd::tl -> k (Some hd) tl)
  | effect (Enqueue y) k -> (fun queue -> k () (queue @ [y]))
  | x -> (fun _ -> x)
  | finally x -> x initial
;;

(* Round-robin thread scheduler. It is an example of a recursively defined handler. *)
let round_robin =
  let dequeue () =
    match perform Dequeue with
    | None -> ()
    | Some t -> t ()
  in
  let rec h () = handler
    | effect Yield k -> perform (Enqueue k) ; dequeue ()
    | effect (Spawn t) k -> perform (Enqueue k) ; with h () handle t ()
    | () ->
       (match perform (Dequeue ()) with
        | None -> ()
        | Some t -> t ())
  in
  h ()
;;

(* An example of nested multithreading. We have a thread which prints
   the letter a and another one which has two sub-threads printing x and y. *)

with queue [] handle
with round_robin handle
 perform (Spawn (fun _ ->
  iter (fun x -> perform (Print x); perform Yield) ["a"; "b"; "c"; "d"; "e"]
  ));
 perform (Spawn (fun _ ->
  iter (fun x -> perform (Print x); perform Yield) ["A"; "B"; "C"; "D"; "E"]
  ))
;;


(* We can run an unbounded amount of threads. The following example enumerates all
   reduced positive fractions less than 1 by spawning a thread for each denominator
   between d and e. *)

let rec fractions d e =
  let rec find_fractions n =
    (* If the fraction is reduced, print it and yield *)
    if gcd n d = 1 then
      perform (Print (to_string n ^ "/" ^ to_string d ^ ", ")); perform Yield
    else ();
    if d > n then
      find_fractions (n+1)
    else ()
  in
  (* Spawn a thread for the next denominator *)
  (if d < e then
     perform (Spawn (fun _ -> perform Yield; fractions (d + 1) e)) else ()) ;
  (* List all the fractions with the current denominator *)
  find_fractions 1
;;

with queue [] handle
with round_robin handle
 fractions 1 10
;;
